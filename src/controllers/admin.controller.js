const Product = require("../models/Product.model");
const Settings = require("../models/Setting.model");
const AppError = require("../utils/AppError");
const logger = require("../utils/logger");
const { success } = require("../utils/response");
const _maybeDeleteFile = require("../utils/mayBeDelete");

exports.renderLoginPage = (req, res) => {
  try {
    res.render("admin/login", {
      title: "Admin Login",
      layout: "layout/auth",
    });
  } catch (error) {
    logger.error("Error rendering login page:", error);
    new AppError("Error rendering login page", 500);
  }
};

exports.renderDashboardPage = async (req, res) => {
  try {
    const settingsDoc = await Settings.findOne().sort({ updatedAt: -1 });
    const stats = {
      totalProducts: await Product.countDocuments(),
      innerCount: await Product.countDocuments({ category: "inner" }),
      mainCount: await Product.countDocuments({ category: "main" }),
      settingsUpdatedAt: settingsDoc ? settingsDoc.updatedAt : null,
    };
    res.render("admin/dashboard", {
      title: "Admin Dashboard",
      layout: "layout/admin",
      stats,
    });
  } catch (error) {
    logger.error("Error fetching dashboard stats:", error);
    new AppError("Error fetching dashboard stats", 500);
  }
};

exports.renderProductsPage = async (req, res) => {
  const limit = 10;
  const page = parseInt(req.query.page) || 1;
  const skip = (page - 1) * limit;

  try {
    const totalProductsCount = await Product.countDocuments();

    const products = await Product.find().skip(skip).limit(limit);
    const totalPages = Math.ceil(totalProductsCount / limit);

    res.render("admin/products", {
      title: "Admin Products",
      layout: "layout/admin",
      products,
      currentPage: page,
      totalPages,
      totalProducts: totalProductsCount,
      req,
    });
  } catch (error) {
    logger.error("Error fetching products:", error);
    new AppError("Error fetching products", 500);
  }
};

exports.logout = async (req, res, next) => {
  try {
    req.session.destroy();
    res.clearCookie("admin");
    res.redirect("/admin/login");
  } catch (error) {
    logger.error("Error logging out:", error);
    new AppError("Error logging out", 500);
  }
};

// controller/product.controller.js
exports.createProduct = async (req, res, next) => {
  try {
    // ุงุณุชุฎุฑุฌ ุงูุญููู ุงูุฃุณุงุณูุฉ (ุบุงูุจุงู ููููููุง strings ูู ุงูููุฑู)
    let { name, description, price, category, stock, colors } = req.body;

    // ุชุฃูุฏ ูู ุฃููุงุน price / stock
    if (price !== undefined) price = Number(price);
    if (stock !== undefined) stock = Number(stock);

    // ุชุญุฏูุฏ subfolder ุนุดุงู ูุฎุฒู ุงููุณุงุฑุงุช
    let subfolder = "other-products";
    if (category === "inner") subfolder = "inner-doors";
    else if (category === "main") subfolder = "main-doors";

    const productData = {
      name,
      description,
      price,
      category,
      stock: stock || 0,
      images: [],
      colors: [],
    };

    // === ูุนุงูุฌุฉ colors ===
    // ูุฏ ูุฌู colors ูู string (JSON) ุฃู ูู array ูุนูู
    let parsedColors = [];
    if (colors) {
      if (typeof colors === "string") {
        try {
          parsedColors = JSON.parse(colors);
        } catch (err) {
          // ูู parse ูุดู ููุชุฑุถ ุฅู ุงููุณุชุฎุฏู ุจุนุช ุงุณู ููู ูุงุญุฏ ุฃู ุดูุก ุบูุฑ ูุชููุน
          // ุฎููู ูุงุฑุบ ุนุดุงู ูุง ููุณุฑ ุงูู schema
          parsedColors = [];
        }
      } else if (Array.isArray(colors)) {
        parsedColors = colors;
      } else {
        parsedColors = [];
      }
    }

    // ูุฌูุฒ parsedColors ุจุญูุซ ูู ุนูุตุฑ ูุญุชูู ุนูู structure ุงููุชููุน
    parsedColors = parsedColors.map((c = {}, i) => ({
      name: c.name || `Color ${i + 1}`,
      hex: c.hex || "#000000",
      images: Array.isArray(c.images) ? c.images : [],
    }));

    // === ุชุฌููุฒ ูููุงุช ุงูู req.files (ุชุบุทูุฉ ูุญุงูุงุช multer ุงููุฎุชููุฉ) ===
    let allFiles = [];
    if (Array.isArray(req.files)) {
      allFiles = req.files;
    } else if (req.files && typeof req.files === "object") {
      // multer.fields => object: { images: [...], colorImages_0: [...] }
      for (const key of Object.keys(req.files)) {
        const val = req.files[key];
        if (Array.isArray(val)) allFiles = allFiles.concat(val);
      }
    }

    // === ุญูุธ ูุณุงุฑุงุช ุงูุตูุฑ ูู ุงูููุฏูู ===
    const newImages = [];

    if (allFiles.length > 0) {
      for (const file of allFiles) {
        // ุงูุชุฑุถูุง ุฅู ูููุงุชู ูุญููุธุฉ ูู /public/images/<subfolder>/<filename>
        // ูุนุฏูู ุงููุณุงุฑ ูู ุชุณุชุฎุฏู CDN ุฃู storage ุขุฎุฑ
        const filePath = `/images/${subfolder}/${file.filename}`;

        // ูุชู ูุนุชุจุฑูุง ุตูุฑุฉ ุฑุฆูุณูุฉุ
        // ููุชุฑุถ ุฃู ุงูุญูู ุงููู ุจููุตู ุจุงูู form ูู ุงูุตูุฑ ุงูุฑุฆูุณูุฉ ุงุณูู 'images'
        // ูุญููู ุตูุฑ ุงูุฃููุงู ุจุชุณุชุฎุฏู ุงุณู ุฒู 'colorImages_<index>'
        const field = file.fieldname || "";

        if (field === "images") {
          newImages.push(filePath);
        } else if (field.startsWith("colorImages_")) {
          // field example: "colorImages_0"
          const parts = field.split("_");
          const index = parseInt(parts[1], 10);
          if (Number.isNaN(index)) continue;

          if (!parsedColors[index]) {
            parsedColors[index] = {
              name: `Color ${index + 1}`,
              hex: "#000000",
              images: [],
            };
          }
          parsedColors[index].images = parsedColors[index].images || [];
          parsedColors[index].images.push(filePath);
        } else {
          // ูู ูุด ูุญุฏุฏุ ูุถููู ููู main images ูู fallback
          newImages.push(filePath);
        }
      }
    }

    // ุฅุฐุง ููู ุตูุฑ ุฑุฆูุณูุฉ ุฌุฏูุฏุฉ - ุฎุฒููู
    productData.images = newImages.length > 0 ? newImages : [];

    // ุฅุฐุง parsedColors ูุงุถูุ ุฎูู ุงูููุฏูู ููุจู ูุตูููุฉ ูุงุฑุบุฉ ุฃู ุงุชุฑูู ููุง ูู
    productData.colors = parsedColors;

    // === ุฅูุดุงุก ุงูููุชุฌ ===
    const created = await Product.create(productData);

    // ุงุณุชุฌุงุจุฉ ูุฌุงุญ (ุชูุชุฑุถ ูุฌูุฏ ุฏุงูุฉ success)
    return success(res, "Product created successfully", created);
  } catch (error) {
    // ููุฌ ููุงุณุจ ูุจุงุณ ุนูู ุงูู middleware ููุนุงูุฌุฉ ุงูุฃุฎุทุงุก
    console.error("Error creating product:", error);
    logger?.error?.("Error creating product:", error);

    // ุงุณุชุฎุฏู next ูุน AppError ุนุดุงู middleware ุงูุฎุทุฃ ูุดุชุบู
    return next(new AppError("Error creating product", 500));
  }
};

exports.updateProduct = async (req, res, next) => {
  try {
    const { name, description, price, category, stock, colors } = req.body;
    const product = await Product.findById(req.params.id);
    if (!product) return next(new AppError("Product not found", 404));

    let subfolder = "other-products";
    if (category === "inner") subfolder = "inner-doors";
    else if (category === "main") subfolder = "main-doors";

    const updateData = { name, description, price, category, stock };

    const newImages = [];
    let parsedColors = [];

    // โ ูุญุงูู ููู JSON ุงูู colors
    if (colors) {
      try {
        parsedColors = JSON.parse(colors);
      } catch {
        parsedColors = product.colors;
      }
    } else {
      parsedColors = product.colors;
    }

    // โ ุชุฌููุฒ ุงูุฃููุงู ูุจู ุงูุฏูุฌ
    parsedColors = parsedColors.map((color, index) => ({
      name: color.name || product.colors[index]?.name || `Color ${index + 1}`,
      hex: color.hex || product.colors[index]?.hex || "#000000",
      images: Array.isArray(color.images)
        ? color.images.length
          ? color.images
          : product.colors[index]?.images || []
        : product.colors[index]?.images || [],
    }));

    // โ ูู ููู ุตูุฑ ุฌุฏูุฏุฉ
    const hasNewFiles = req.files && req.files.length > 0;

    if (hasNewFiles) {
      // ๐งน ุฃููุงู ูุญุฐู ุงูุตูุฑ ุงููุฏููุฉ ูููุง (main + colors)
      if (Array.isArray(product.images)) {
        product.images.forEach((imgPath) => _maybeDeleteFile(imgPath));
      }
      if (Array.isArray(product.colors)) {
        product.colors.forEach((color) => {
          if (Array.isArray(color.images)) {
            color.images.forEach((imgPath) => _maybeDeleteFile(imgPath));
          }
        });
      }

      // โ ุซู ูุถูู ุงูุตูุฑ ุงูุฌุฏูุฏุฉ
      for (const file of req.files) {
        const filePath = `/images/${subfolder}/${file.filename}`;

        if (file.fieldname === "images") {
          newImages.push(filePath);
        } else if (file.fieldname.startsWith("colorImages_")) {
          const index = parseInt(file.fieldname.split("_")[1]);
          if (!parsedColors[index]) {
            parsedColors[index] = {
              name: `Color ${index + 1}`,
              hex: "#000000",
              images: [],
            };
          }
          parsedColors[index].images.push(filePath);
        }
      }

      // โ ุงูุตูุฑ ุงูุฑุฆูุณูุฉ ุงูุฌุฏูุฏุฉ
      updateData.images = newImages;
    } else {
      // ูููุด ุตูุฑ ุฌุฏูุฏุฉ โ ุงุณุชุฎุฏู ุงููุฏููุฉ
      updateData.images = product.images;
    }

    // โ ุงูุฃููุงู ุจุนุฏ ุงูุฏูุฌ ุงูููุงุฆู
    updateData.colors = parsedColors;

    const updated = await Product.findByIdAndUpdate(req.params.id, updateData, {
      new: true,
    });

    success(res, "Product updated successfully", updated);
  } catch (error) {
    console.error("Error updating product:", error);
    return next(new AppError("Error updating product", 500));
  }
};

exports.getProductById = async (req, res, next) => {
  try {
    const product = await Product.findById(req.params.id);
    if (!product) return next(new AppError("Product not found", 404));
    success(res, "Product fetched successfully", product);
  } catch (error) {
    logger.error("Error fetching product:", error);
    return next(new AppError("Error fetching product", 500));
  }
};
// ุนุฑุถ ูู ุงูููุชุฌุงุช ูุน ุฏุนู ุงูู pagination
exports.getProducts = async (req, res, next) => {
  try {
    const page = parseInt(req.query.page, 10) || 1;
    const limit = 10;
    const skip = (page - 1) * limit;

    const products = await Product.find({})
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    const totalProducts = await Product.countDocuments();
    const totalPages = Math.ceil(totalProducts / limit);

    const responseData = {
      products: products,
      pagination: {
        currentPage: page,
        totalPages: totalPages,
        totalProducts: totalProducts,
        hasNextPage: page < totalPages,
        hasPrevPage: page > 1,
      },
    };

    success(res, "Products fetched successfully", responseData);
  } catch (error) {
    logger.error(error);
    return next(new AppError("Error fetching products", 500));
  }
};

exports.deleteProduct = async (req, res, next) => {
  try {
    const product = await Product.findById(req.params.id);
    if (!product) return next(new AppError("Product not found", 404));

    // โ ุญุฐู ุงูุตูุฑ ุงูุฃุณุงุณูุฉ
    if (Array.isArray(product.images)) {
      product.images.forEach((imgPath) => _maybeDeleteFile(imgPath));
    }

    // โ ุญุฐู ุตูุฑ ุงูุฃููุงู
    if (Array.isArray(product.colors)) {
      product.colors.forEach((color) => {
        if (Array.isArray(color.images)) {
          color.images.forEach((imgPath) => _maybeDeleteFile(imgPath));
        }
      });
    }

    await product.deleteOne();

    success(res, "Product deleted successfully", product);
  } catch (error) {
    console.error(error);
    return next(new AppError("Error deleting product", 500));
  }
};
