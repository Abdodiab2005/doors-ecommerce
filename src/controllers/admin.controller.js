const Product = require("../models/Product.model");
const Settings = require("../models/Setting.model");
const AppError = require("../utils/AppError");
const logger = require("../utils/logger");
const { success } = require("../utils/response");
const _maybeDeleteFile = require("../utils/mayBeDelete");
const { invalidateCache } = require("../middlewares/cache");

exports.renderLoginPage = (req, res) => {
  try {
    res.render("admin/login", {
      title: "Admin Login",
      layout: "layout/auth",
    });
  } catch (error) {
    logger.error("Error rendering login page:", error);
    new AppError("Error rendering login page", 500);
  }
};

exports.renderDashboardPage = async (req, res) => {
  try {
    const settingsDoc = await Settings.findOne().sort({ updatedAt: -1 });
    const stats = {
      totalProducts: await Product.countDocuments(),
      innerCount: await Product.countDocuments({ category: "inner" }),
      mainCount: await Product.countDocuments({ category: "main" }),
      settingsUpdatedAt: settingsDoc ? settingsDoc.updatedAt : null,
    };
    res.render("admin/dashboard", {
      title: "Admin Dashboard",
      layout: "layout/admin",
      stats,
    });
  } catch (error) {
    logger.error("Error fetching dashboard stats:", error);
    new AppError("Error fetching dashboard stats", 500);
  }
};

exports.renderProductsPage = async (req, res) => {
  const limit = 10;
  const page = parseInt(req.query.page) || 1;
  const skip = (page - 1) * limit;

  try {
    const totalProductsCount = await Product.countDocuments();

    const products = await Product.find().skip(skip).limit(limit);
    const totalPages = Math.ceil(totalProductsCount / limit);

    res.render("admin/products", {
      title: "Admin Products",
      layout: "layout/admin",
      products,
      currentPage: page,
      totalPages,
      totalProducts: totalProductsCount,
      req,
    });
  } catch (error) {
    logger.error("Error fetching products:", error);
    new AppError("Error fetching products", 500);
  }
};

exports.logout = async (req, res, next) => {
  try {
    req.session.destroy();
    res.clearCookie("admin");
    res.redirect("/admin/login");
  } catch (error) {
    logger.error("Error logging out:", error);
    new AppError("Error logging out", 500);
  }
};

// controller/product.controller.js
exports.createProduct = async (req, res, next) => {
  try {
    // ุงุณุชุฎุฑุฌ ุงูุญููู ุงูุฃุณุงุณูุฉ (ุบุงูุจุงู ููููููุง strings ูู ุงูููุฑู)
    let { name, description, price, category, stock, colors } = req.body;

    // ูู JSON ุงูุฎุงุต ุจุงูุงุณู ูุงููุตู ูู ูุจุนูุช ูุณูุณูุฉ
    try {
      if (typeof name === "string") name = JSON.parse(name);
    } catch {
      console.warn("Invalid name JSON, keeping as string");
    }
    try {
      if (typeof description === "string")
        description = JSON.parse(description);
    } catch {
      console.warn("Invalid description JSON, keeping as string");
    }

    // ุชุฃูุฏ ูู ุฃููุงุน price / stock
    if (price !== undefined) price = Number(price);
    if (stock !== undefined) stock = Number(stock);

    // ุชุญุฏูุฏ subfolder ุนุดุงู ูุฎุฒู ุงููุณุงุฑุงุช
    let subfolder = "other-products";
    if (category === "inner") subfolder = "inner-doors";
    else if (category === "main") subfolder = "main-doors";

    const productData = {
      name,
      description,
      price,
      category,
      stock: stock || 0,
      images: [],
      colors: [],
    };

    // === thumbnail ===
    let thumbnailFile = null;
    if (req.files && Array.isArray(req.files)) {
      thumbnailFile = req.files.find((f) => f.fieldname === "thumbnail");
    } else if (req.files && typeof req.files === "object") {
      for (const key in req.files) {
        const val = req.files[key];
        if (Array.isArray(val)) {
          const found = val.find((f) => f.fieldname === "thumbnail");
          if (found) thumbnailFile = found;
        }
      }
    }

    if (thumbnailFile) {
      productData.thumbnail = `/images/${subfolder}/${thumbnailFile.filename}`;
    }

    // === ูุนุงูุฌุฉ colors ===
    // ูุฏ ูุฌู colors ูู string (JSON) ุฃู ูู array ูุนูู
    let parsedColors = [];
    if (colors) {
      if (typeof colors === "string") {
        try {
          parsedColors = JSON.parse(colors);
        } catch (err) {
          // ูู parse ูุดู ููุชุฑุถ ุฅู ุงููุณุชุฎุฏู ุจุนุช ุงุณู ููู ูุงุญุฏ ุฃู ุดูุก ุบูุฑ ูุชููุน
          // ุฎููู ูุงุฑุบ ุนุดุงู ูุง ููุณุฑ ุงูู schema
          parsedColors = [];
        }
      } else if (Array.isArray(colors)) {
        parsedColors = colors;
      } else {
        parsedColors = [];
      }
    }

    // ูุฌูุฒ parsedColors ุจุญูุซ ูู ุนูุตุฑ ูุญุชูู ุนูู structure ุงููุชููุน
    parsedColors = parsedColors.map((c = {}, i) => ({
      name: c.name || `Color ${i + 1}`,
      hex: c.hex || "#000000",
      images: Array.isArray(c.images) ? c.images : [],
    }));

    // === ุชุฌููุฒ ูููุงุช ุงูู req.files (ุชุบุทูุฉ ูุญุงูุงุช multer ุงููุฎุชููุฉ) ===
    let allFiles = [];
    if (Array.isArray(req.files)) {
      allFiles = req.files;
    } else if (req.files && typeof req.files === "object") {
      // multer.fields => object: { images: [...], colorImages_0: [...] }
      for (const key of Object.keys(req.files)) {
        const val = req.files[key];
        if (Array.isArray(val)) allFiles = allFiles.concat(val);
      }
    }

    // === ุญูุธ ูุณุงุฑุงุช ุงูุตูุฑ ูู ุงูููุฏูู ===
    const newImages = [];

    if (allFiles.length > 0) {
      for (const file of allFiles) {
        // ุงูุชุฑุถูุง ุฅู ูููุงุชู ูุญููุธุฉ ูู /public/images/<subfolder>/<filename>
        // ูุนุฏูู ุงููุณุงุฑ ูู ุชุณุชุฎุฏู CDN ุฃู storage ุขุฎุฑ
        const filePath = `/images/${subfolder}/${file.filename}`;

        // ูุชู ูุนุชุจุฑูุง ุตูุฑุฉ ุฑุฆูุณูุฉุ
        // ููุชุฑุถ ุฃู ุงูุญูู ุงููู ุจููุตู ุจุงูู form ูู ุงูุตูุฑ ุงูุฑุฆูุณูุฉ ุงุณูู 'images'
        // ูุญููู ุตูุฑ ุงูุฃููุงู ุจุชุณุชุฎุฏู ุงุณู ุฒู 'colorImages_<index>'
        const field = file.fieldname || "";

        if (field === "images") {
          newImages.push(filePath);
        } else if (field.startsWith("colorImages_")) {
          // field example: "colorImages_0"
          const parts = field.split("_");
          const index = parseInt(parts[1], 10);
          if (Number.isNaN(index)) continue;

          if (!parsedColors[index]) {
            parsedColors[index] = {
              name: `Color ${index + 1}`,
              hex: "#000000",
              images: [],
            };
          }
          parsedColors[index].images = parsedColors[index].images || [];
          parsedColors[index].images.push(filePath);
        } else {
          // ูู ูุด ูุญุฏุฏุ ูุถููู ููู main images ูู fallback
          newImages.push(filePath);
        }
      }
    }

    // ุฅุฐุง ููู ุตูุฑ ุฑุฆูุณูุฉ ุฌุฏูุฏุฉ - ุฎุฒููู
    productData.images = newImages.length > 0 ? newImages : [];

    // ุฅุฐุง parsedColors ูุงุถูุ ุฎูู ุงูููุฏูู ููุจู ูุตูููุฉ ูุงุฑุบุฉ ุฃู ุงุชุฑูู ููุง ูู
    productData.colors = parsedColors;

    // === ุฅูุดุงุก ุงูููุชุฌ ===
    const created = await Product.create(productData);

    // Invalidate product cache
    await invalidateCache('*products*');

    // ุงุณุชุฌุงุจุฉ ูุฌุงุญ (ุชูุชุฑุถ ูุฌูุฏ ุฏุงูุฉ success)
    return success(res, "Product created successfully", created);
  } catch (error) {
    // ููุฌ ููุงุณุจ ูุจุงุณ ุนูู ุงูู middleware ููุนุงูุฌุฉ ุงูุฃุฎุทุงุก
    console.error("Error creating product:", error);
    logger?.error?.("Error creating product:", error);

    // ุงุณุชุฎุฏู next ูุน AppError ุนุดุงู middleware ุงูุฎุทุฃ ูุดุชุบู
    return next(new AppError("Error creating product", 500));
  }
};

exports.updateProduct = async (req, res, next) => {
  try {
    let { name, description, price, category, stock, colors } = req.body;

    // ๐ ุงูุญุตูู ุนูู ุงูููุชุฌ ุงูุญุงูู
    const product = await Product.findById(req.params.id);
    if (!product) return next(new AppError("Product not found", 404));

    // ๐งฉ ูู JSON ููุงุณู ูุงููุตู ูู ุฌุงููู ูู string
    try {
      if (typeof name === "string") name = JSON.parse(name);
    } catch {
      name = product.name;
    }

    try {
      if (typeof description === "string")
        description = JSON.parse(description);
    } catch {
      description = product.description;
    }

    // ๐ ุชุญุฏูุฏ ูุฌูุฏ ุงูุตูุฑ
    let subfolder = "other-products";
    if (category === "inner") subfolder = "inner-doors";
    else if (category === "main") subfolder = "main-doors";

    // ๐งฑ ุจูุงูุงุช ุฃุณุงุณูุฉ ููุชุญุฏูุซ
    const updateData = {
      name: name || product.name,
      description: description || product.description,
      price: price !== undefined ? Number(price) : product.price,
      category: category || product.category,
      stock: stock !== undefined ? Number(stock) : product.stock,
    };

    // ๐ผ๏ธ Thumbnail logic
    let thumbnailFile = null;
    if (req.files && Array.isArray(req.files)) {
      thumbnailFile = req.files.find((f) => f.fieldname === "thumbnail");
    } else if (req.files && typeof req.files === "object") {
      for (const key in req.files) {
        const val = req.files[key];
        if (Array.isArray(val)) {
          const found = val.find((f) => f.fieldname === "thumbnail");
          if (found) thumbnailFile = found;
        }
      }
    }

    // ๐๏ธ ููุฌูู ุญุฐู/ุชุญุฏูุซ ุงูู Thumbnail
    if (thumbnailFile) {
      // ุฅุฐุง ููู ููู ุฌุฏูุฏุ ุงุญุฐู ุงููุฏูู (ูู ููุฌูุฏ)
      if (product.thumbnail) {
        _maybeDeleteFile(product.thumbnail);
      }
      updateData.thumbnail = `/images/${subfolder}/${thumbnailFile.filename}`;
    } else if (req.body.thumbnailOld) {
      // ูู ูููุด ููู ุฌุฏูุฏุ ุจุณ ุงููุณุชุฎุฏู ุฃุจูู ุนูู ุงููุฏูู
      updateData.thumbnail = req.body.thumbnailOld;
    } else {
      // ูู ูููุด ููู ุฌุฏูุฏุ ูุงููุณุชุฎุฏู *ุญุฐู* ุงููุฏูู
      if (product.thumbnail) {
        _maybeDeleteFile(product.thumbnail);
      }
      updateData.thumbnail = "";
    }

    // ๐ผ๏ธ ุงูุตูุฑ ุงูุฑุฆูุณูุฉ (main images)
    let imagesFinal = []; // ุงูุตูุฑ "ุงููุฏููุฉ" ุงูุชู ุฃุจูู ุนูููุง ุงููุณุชุฎุฏู
    if (req.body.imagesOld) {
      try {
        imagesFinal = JSON.parse(req.body.imagesOld);
      } catch {
        imagesFinal = [];
      }
    }

    // ๐๏ธ ููุฌูู ุญุฐู ุงูุตูุฑ ุงูุฑุฆูุณูุฉ
    // ููุงุฑู ุงูุตูุฑ ุงูุฃุตููุฉ ุจุงูุตูุฑ ุงูุชู ุฃุจูู ุนูููุง ุงููุณุชุฎุฏู
    const keptImagesSet = new Set(imagesFinal);
    const originalImages = product.images || [];
    for (const imgPath of originalImages) {
      if (!keptImagesSet.has(imgPath)) {
        // ุฅุฐุง ุงูุตูุฑุฉ ุงูุฃุตููุฉ ูุด ููุฌูุฏุฉ ูู "ุงูููุจูุงุฉ"ุ ุงุญุฐููุง
        _maybeDeleteFile(imgPath);
      }
    }

    // ุงูุตูุฑ ุงูุฌุฏูุฏุฉ ุงููุฑููุนุฉ
    const newImages = [];
    const allFiles = Array.isArray(req.files)
      ? req.files
      : Object.values(req.files || {}).flat();

    for (const file of allFiles) {
      if (file.fieldname === "images") {
        newImages.push(`/images/${subfolder}/${file.filename}`);
      }
    }

    // ุงููุงุฆูุฉ ุงูููุงุฆูุฉ = ุงูููุจูุงุฉ + ุงูุฌุฏูุฏุฉ
    updateData.images = [...imagesFinal, ...newImages];

    // ๐จ ูุนุงูุฌุฉ ุงูุฃููุงู
    let parsedColors = []; // ุงูุฃููุงู ูู ุงูููุฑู (JSON)
    if (colors) {
      try {
        parsedColors = JSON.parse(colors);
      } catch {
        parsedColors = product.colors || [];
      }
    } else {
      parsedColors = product.colors || [];
    }

    const mergedColors = parsedColors.map((c, i) => {
      // ุงูุตูุฑ ุงููุฏููุฉ "ุงูููุจูุงุฉ" ููุฐุง ุงูููู
      let oldImages = [];
      if (req.body[`colorsOld_${i}`]) {
        try {
          oldImages = JSON.parse(req.body[`colorsOld_${i}`]);
        } catch {
          oldImages = [];
        }
      }

      // ๐๏ธ ููุฌูู ุญุฐู ุตูุฑ ุงูุฃููุงู
      // ูุงู: ูุฐุง ูุนุชูุฏ ุนูู ุฃู ุชุฑุชูุจ ุงูุฃููุงู ูู ูุชุบูุฑ ูู ุงูููุฑู
      const originalColor =
        product.colors && product.colors[i] ? product.colors[i] : null;
      const originalColorImages =
        originalColor && Array.isArray(originalColor.images)
          ? originalColor.images
          : [];
      const keptColorImagesSet = new Set(oldImages);

      for (const imgPath of originalColorImages) {
        if (!keptColorImagesSet.has(imgPath)) {
          _maybeDeleteFile(imgPath);
        }
      }

      // ุงูุตูุฑ ุงูุฌุฏูุฏุฉ ููุฐุง ุงูููู
      const newColorImages = [];
      const colorFiles = Object.keys(req.files || {})
        .filter((key) => key === `colorImages_${i}`)
        .flatMap((key) => req.files[key]);

      if (colorFiles && colorFiles.length) {
        colorFiles.forEach((file) => {
          newColorImages.push(`/images/${subfolder}/${file.filename}`);
        });
      }

      return {
        name: c.name || product.colors[i]?.name || `Color ${i + 1}`,
        hex: c.hex || product.colors[i]?.hex || "#000000",
        images: [...oldImages, ...newColorImages], // ุงููุงุฆูุฉ ุงูููุงุฆูุฉ = ุงูููุจูุงุฉ + ุงูุฌุฏูุฏุฉ
      };
    });

    updateData.colors = mergedColors;

    // ๐พ ุชูููุฐ ุงูุชุญุฏูุซ
    const updated = await Product.findByIdAndUpdate(req.params.id, updateData, {
      new: true,
    });

    // Invalidate product cache
    await invalidateCache('*products*');

    success(res, "Product updated successfully", updated);
  } catch (error) {
    console.error("Error updating product:", error);
    return next(new AppError("Error updating product", 500));
  }
};

exports.getProductById = async (req, res, next) => {
  try {
    const product = await Product.findById(req.params.id);
    if (!product) return next(new AppError("Product not found", 404));
    success(res, "Product fetched successfully", product);
  } catch (error) {
    logger.error("Error fetching product:", error);
    return next(new AppError("Error fetching product", 500));
  }
};
// ุนุฑุถ ูู ุงูููุชุฌุงุช ูุน ุฏุนู ุงูู pagination
exports.getProducts = async (req, res, next) => {
  try {
    const page = parseInt(req.query.page, 10) || 1;
    const limit = 10;
    const skip = (page - 1) * limit;

    const products = await Product.find({})
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    const totalProducts = await Product.countDocuments();
    const totalPages = Math.ceil(totalProducts / limit);

    const responseData = {
      products: products,
      pagination: {
        currentPage: page,
        totalPages: totalPages,
        totalProducts: totalProducts,
        hasNextPage: page < totalPages,
        hasPrevPage: page > 1,
      },
    };

    success(res, "Products fetched successfully", responseData);
  } catch (error) {
    logger.error(error);
    return next(new AppError("Error fetching products", 500));
  }
};

exports.deleteProduct = async (req, res, next) => {
  try {
    const product = await Product.findById(req.params.id);
    if (!product) return next(new AppError("Product not found", 404));

    // โ ุญุฐู ุงูุตูุฑ ุงูุฃุณุงุณูุฉ
    if (Array.isArray(product.images)) {
      product.images.forEach((imgPath) => _maybeDeleteFile(imgPath));
    }

    // โ ุญุฐู ุตูุฑ ุงูุฃููุงู
    if (Array.isArray(product.colors)) {
      product.colors.forEach((color) => {
        if (Array.isArray(color.images)) {
          color.images.forEach((imgPath) => _maybeDeleteFile(imgPath));
        }
      });
    }

    await product.deleteOne();

    // Invalidate product cache
    await invalidateCache('*products*');

    success(res, "Product deleted successfully", product);
  } catch (error) {
    console.error(error);
    return next(new AppError("Error deleting product", 500));
  }
};
